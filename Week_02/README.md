学习笔记
哈希表、映射、集合的实现与特性
哈希表，是根据关键码值而直接进行访问的数据结构；
通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度；

Hash Function；

hash碰撞；
1.拉链法解决hash碰撞；

好的情况下，hash表的插入、删除、查询的时间复杂度是O(1);
最坏的情况下，hash冲突严重时，退化成链表；


树、二叉树、二叉搜索树的实现和特性

链表，无论是单向链表还是双向链表，查找某个节点只能从前往后或者从后往前遍历，时间复杂度是O(n);
后来出现了跳表，增加多级索引，提高查询效率；


树：
没有环就是树，有环就是图；

树的节点定义：
public class TreeNode{
	public int val;
	public TreeNode left,right;
	public TreeNode(int val){
		this.val = val;
		this.left = null;
		this.right = null;
	}
}

二叉树：
每个节点只有两个子节点；

二叉树的遍历：
前序遍历：根-左-右
中序遍历：左-根-右
后序遍历：左-右-根


二叉搜索树：
空树；
1.左子树上所有节点的值均小于它的根节点的值；
2.右子树上所有节点的值均大于它的根节点的值；

大部分操作都是O(logn)的时间复杂度；


删除节点：
1.删除叶子节点，直接删除即可；
2.非叶子节点，要拉一个上来垫背，一般选择右子树中最小的节点；

如果树退化成链表，那就是O(n)时间复杂度；


二叉树的中序遍历：
递归本身不存在所谓的效率差、效率低的问题；
只要你程序本身的话算法复杂度没有写残即可；
举个例子Fibonacci数列如果你只是傻递归，没有把中间结果存储起来的话；
导致本身线性可以解决的问题，需要指数级的时间复杂度才能解决的话，这是不合理的，
但是锅本身不在递归上面，而是在你程序本身写傻了；
写傻的原因可能是对它的状态树不是特别熟悉写傻的；
所以本身的话锅并不在递归而是你没有用缓存；
那么递归和非递归的方式，递归是不是一定会慢一点？
其实它慢的地方就是在它要多开一些栈，如果它递归很深的话；
的确可能会有这样的问题，但是一般情况下，而且现在计算机的话，
它的存储方式和编译器对于递归，特别是尾递归的优化，我们可以直接认为；
递归和循环效率是一样的；



堆和二叉堆的实现和特性
堆的特性：
可以迅速找到一堆数中的最大或者最小值的数据结构；
将根节点最大的堆叫做大顶堆或者大根堆，根节点最小的堆叫做小顶堆或小根堆；
常见的堆有二叉堆，斐波那契堆；

假设是大顶堆，常见操作：
find-max: O(1)
delete-max: O(logN)
insert(create): O(logN)or O(1)

要么找最大，要么找最小；

二叉堆性质：
通过完全二叉树来实现（注意，不是二叉搜索树）
二叉堆（大顶堆）满足一下性质：
1.是一棵完全树（除了叶子节点，其他节点都是丰满的）
2.树中任意节点的值总是 >= 其子节点的值；

这两个性质就可以保证根节点肯定是最大的；

二叉堆实现细节：
1.二叉堆一般都通过 ”数组“来实现；
2.假设“第一个元素”在数组中的索引为0的话，
则父节点和子节点的位置关系如下：
1.索引为i的左孩子的索引是(2*i+1);
2.索引为i的右孩子的索引是(2*i+2);
3.索引为i的父节点的索引是floor((i-1)/2);

insert 插入操作：O(logN)
1.新元素一律先插入到堆的尾部
2.一次向上调整整个堆的结构（一直到根即可）
HeapifyUp
重新维护一下，让其满足大顶堆或者小顶堆特性；

Delete Max 删除堆顶操作：O(logN)
1.将堆尾元素替换到顶部（即堆顶被替代删除掉）；
2.依次从根部向下调整整个堆的结构（一直到堆尾即可）；
为什么是将堆尾的元素用来替代堆顶元素再进行调整？
因为二叉堆是一颗完全二叉树，要保证除了叶子节点之外都是丰满的，所以会将最后一个叶子节点作为替代堆顶元素；
HeapifyDown

Heap是一个抽象的数据结构，有很多中实现方式；
在工程当中可以使用PriorityQueue来作为Heap的应用；

图的实现和特性









